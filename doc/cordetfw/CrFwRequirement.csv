Domain|Name|Kind|Text|Implementation|Verification|Remarks
AST|01|S|The CORDET Framework shall implement the Application State Machine of figure \ref{fig:AppSM}|The Application State Machine is implemented in \texttt{CrFwAppSm}.|The behaviour of the Application State Machine is verified in table \ref{tab:verAppSM}. |
AST|02|A|The Application State Machine shall support the adaptation points AST-*.|||
AST|03|S|The CORDET Framework shall provide an API through which applications can query the Application State Machine for its current state.|This API is provided by functions \texttt{CrFwAppSmIsInStartUp}, \texttt{CrFwAppSmIsInNormal},  \texttt{CrFwAppSmIsInReset} and  \texttt{CrFwAppSmIsInShutdown}.|The state query functions are guaranteed to be verified because the Test Suite has 100\% statement coverage.|
AST|04|C|The Application Start-Up Procedure shall include the instantiation, initialization and configuration of all components subject to early instantiation.|||
AST|05|C|The application Start-Up Procedure shall only terminate if all components subject to early instantiation are in state CONFIGURED.|||
AST|06|C|The Application Reset Procedure shall include the sending of command \texttt{Reset} to all application components.|||
AST|07|C|The Application Reset Procedure shall only terminate if all application components are in state CONFIGURED.|||
AST|08|C|The Application Shutdown Procedure shall include the sending of command \texttt{Shutdown} to all application components.|||
BAS|01|S|All components provided by the CORDET Framework shall implement the behaviour of the Base State Machine of figure \ref{fig:BaseSM}|The behaviour of the Base State Machine is implemented in \texttt{CrFwBaseCmp}. Each framework component is built around a state machine instance which is derived from the Base State Machine (see section 5 of reference [CR-UM]). State machine derivation is done using the extension mechanism of the C1 Implementation of the FW Profile  which guarantees that the derived state machines have the same behaviour as the base state machine. Framework component are instantiated by Make functions (see section 6.1 of reference [CR-UM]). The creation of their state machine as an extension of the Base State Machine is done in these Make functions.|The behaviour of the Base State Machine is verified in table \ref{tab:verBaseSM}. The behaviour of its two procedures (Initialization Procedure and Reset Procedure) is verified in table \ref{tab:verInitProc} and \ref{tab:verResetProc}). The inheritance of this behaviour by all other framework state machines is guaranteed by the extension mechanism of the FW Profile as it is implemented in the C1 Implementation and by the fact that all framework components are created as extension of a Base State Machine.|
BAS|02|S|The CORDET Framework shall implement an API through which applications can query a CORDET Component for its current state (including, if applicable, its current sub-state).|Only two levels of state machine embedding are used in the C2 Implementation. Query of the outer state (which is a state of the Base State Machine) is provided by functions: \texttt{CrFwCmpIsInCreated}, \texttt{CrFwCmpIsInInitialized} and \texttt{CrFwCmpIsInConfigured}. Embedded states are only embedded in state CONFIGURED and query of this embedded state is provided by functions with names like \texttt{CrFw$\langle$Type$\rangle$IsIn$\langle$State$\rangle$($\langle$Inst$\rangle$)}.|The state query functions are guaranteed to be verified because the Test Suite has 100\% statement coverage.|
BAS|03|C|All components provided by application developers shall implement the behaviour of the Base State Machine.|||
FAC|01|S|The factory components shall be provided as extensions of the Base Component.|The InFactory component is created by function \texttt{CrFwInFactoryMake} which creates it as an extension of the Base State Machine. Similarly, OutFactory component is created by function \texttt{CrFwOutFactoryMake} which creates it as an extension of the Base State Machine.|InFactory creation is verified in the test cases in \texttt{CrFwInFactoryTestCase.h} and OutFactory creation is verified in the test cases in \texttt{CrFwOutFactoryTestCase.h}.|
FAC|02|S|The factory components shall define an API offering two operations: \texttt{Make} and \texttt{Release}.|The make operations for the InFactory are implemented in functions \texttt{CrFwInFactorMakeInCmd} and \texttt{CrFwInFactorMakeInRep}. The release operations are implemented in functions \texttt{CrFwInFactorReleaseInCmd} and \texttt{CrFwInFactorReleaseInRep}. The make operation for the OutFactory is implemented in function \texttt{CrFwOutFactorMakeOutCmp}. The release operation is implemented in function \texttt{CrFwOutFactorReleaseOutCmp}.|The make operation for InCommands is verified in test case \texttt{CrFwInCmdTestCase1}. The make operation for InReports is verified in test case \texttt{CrFwInRepTestCase1}. The make operation for OutComponents is verified in test case \texttt{CrFwOutCmpTestCase1}. |
FAC|03|S|The \texttt{Make} operation shall either fail and return nothing or succeed and return a component instance of the type specified by the \texttt{Make} arguments.|The make operations for the InFactory are implemented in functions \texttt{CrFwInFactorMakeInCmd} and \texttt{CrFwInFactorMakeInRep}. The make operation for the OutFactory is implemented in function \texttt{CrFwOutFactorMakeOutCmp}.|For the InFactory, successful creation is verified in \texttt{CrFwInFactoryTestCase1}; unsuccessful creation is verified in \texttt{CrFwInFactoryTestCase2} and \texttt{CrFwInFactoryTestCase5}. For the OutFactory, successful creation is verified in \texttt{CrFwOutFactoryTestCase1}; unsuccessful creation is verified in \texttt{CrFwOutFactoryTestCase2}. |
FAC|04|S|The \texttt{Release} operation shall take as argument the component instance to be released.|The release operations for the InFactory are implemented in functions \texttt{CrFwInFactorReleaseInCmd} and \texttt{CrFwInFactorReleaseInRep}. The release operation for the OutFactory is implemented in function \texttt{CrFwOutFactorReleaseOutCmp}.|The release functions are guaranteed to be verified because the Test Suite has 100\% statement coverage.|
FAC|05|A|The factory components shall support the adaptation points FAC-*.|||
FAC|06|C|An application shall instantiate factory components only once.|||
FAC|07|C|An application shall not use a component instance which has been released through a call to operation \texttt{Release}.|||
ICM|01|S|The CORDET Framework shall provide an InCommand component as an extension of the Base Component to encapsulate an incoming command in a provider application.|The InCommand components are created by function \texttt{CrFwInFactoryMakeInCmd} which returns an instance taken from a pool of pre-allocated components. The pre-allocated components are created by function \texttt{InFactoryInitAction} as extensions of a Base InCommand which is created by function \texttt{CrFwInCmdMakeBase} and which is itself an extension of a Base State Machine.|The function \texttt{CrFwInFactoryMakeInCmd} is verified in test case \texttt{CrFwInCmdTestCase1}.|
ICM|02|S|The behaviour of the InCommand component in state CONFIGURED shall be as defined by the InCommand State Machine of figure \ref{fig:InCommand}|The function \texttt{CrFwInCmdMakeBase} builds the Base InCommand from which all InCommands are derived by extending the Base State Machine and then embedding within its CONFIGURED state an InCommand State Machine.|The behaviour of the InCommand State Machine is verified in table \ref{tab:verInCmdSM}.|
ICM|03|A|The InCommand component shall support the adaptation points ICM-*.|||
ICM|04|S|The InCommand component shall provide visibility over the value of all the attributes of the command it encapsulates.|The InCommand attributes can be accessed through functions with names like: \texttt{CrFwInCmdGet*}.|The \texttt{CrFwInCmdGet*} functions are verified in test case \texttt{CrFwInCmdTestCase1}.|
IFT|01|S|The InFactory component shall encapsulate the instance creation process for InCommand and InReport components.|Instances of InCommand are created by function \texttt{CrFwInFactoryMakeInCmd}. Instances of InReport are created by function \texttt{CrFwInFactoryMakeInRep}.|Function  \texttt{CrFwInFactoryMakeInCmd} is verified in test case \texttt{CrFwInCmdTestCase1}. Function  \texttt{CrFwInFactoryMakeInRep} is verified in test case \texttt{CrFwInRepTestCase1}.|
IFT|02|S|The \texttt{Make} operation of the InFactory component shall take as arguments the service type, command or report sub-type and discriminant value of the command or report to be encapsulated by the InCommand or InReport.|Instances of InCommand are created by function \texttt{CrFwInFactoryMakeInCmd}. Instances of InReport are created by function \texttt{CrFwInFactoryMakeInRep}.|Function  \texttt{CrFwInFactoryMakeInCmd} is verified in test case \texttt{CrFwInCmdTestCase1}. Function  \texttt{CrFwInFactoryMakeInRep} is verified in test case \texttt{CrFwInRepTestCase1}.|
IFT|03|S|The InCommands or InReports returned by the \texttt{Make} operation of the OutFactory shall have their service type, command/report sub-type, and discriminant attribute set in accordance with the value of the arguments of the Make operation.|Instances of InCommand are created by function \texttt{CrFwInFactoryMakeInCmd}. Instances of InReport are created by function \texttt{CrFwInFactoryMakeInRep}.|The correctness of the type, sub-type and discriminant of a newly created InCommand is verified in test case \texttt{ CrFwInCmdTestCase1}. The correctness of the type, sub-type and discriminant of a newly created InReport is verified in test case \texttt{ CrFwInRepTestCase1}.|
IFT|05|A|The InFactory shall support the adaptation points IFT-*.|||
ILD|01|S|The CORDET Framework shall provide an InLoader component as an extension of the Base Component.|The InLoader component is created by function \texttt{CrFwInLoaderMake} which creates it as an extension of the Base State Machine.|InLoader creation is verified in the test cases in \texttt{CrFwInLoaderTestCase.h}.|
ILD|02|A|The InLoader component shall support the adaptation points ILD-*.|||
ILD|03|S|The InLoader component shall offer a \texttt{Load} operation to load a command or report in an InManager.|The Load operation is implemented by function \texttt{CrFwInLoaderLoad}.|Function \texttt{CrFwInLoaderLoad} is verified in test cases \texttt{CrFwInLoaderTestCase3} to \texttt{CrFwInLoaderTestCase11}.|
ILD|04|S|The \texttt{Load} operation shall run the InLoader Execution Procedure of figure \ref{fig:InLoaderExecution}|The InLoader Execution Procedure is implemented by function \texttt{InLoaderExecAction}.|The behaviour of the InLoader Execution Procedure is verified in table \ref{tab:verInLoaderExecProc}. This procedure uses the InLoader Load Command/Report Procedure which is verified in table \ref{tab:verInLoaderLoadCmdRepProc}.|
ILD|05|C|An application shall instantiate an InLoader component only once.|||
IMG|01|S|The CORDET Framework shall provide an InManager component as an extension of the Base Component.|The InManager component is created by function \texttt{CrFwInManagerMake} which creates it as an extension of the Base State Machine.|InManager creation is verified in the test cases in \texttt{CrFwInManagerTestCase.h}.|
IMG|02|A|The InManager component shall support the adaptation points IMG-*.|||
IMG|03|S|The InManager component shall offer a \texttt{Load} operation to load an InCommand or InReport instance in the Pending Command/Report List (PCRL).|The Load operation is implemented by function \texttt{CrFwInManagerLoad}.|Function  \texttt{CrFwInManagerLoad} is verified in test case \texttt{CrFwInManagerTestCase2}.|
IMG|04|S|The Load operation shall run the InManager Load Procedure of figure \ref{fig:InManagerLoad}|The OutManager Load Procedure is implemented by function \texttt{CrFwOutManagerLoad}.|The Load Procedure has two branches both of which are verified in test case \texttt{CrFwInManagerTestCase2}. The 'PCRL Not Full' branch is also verified in test cases \texttt{CrFwOutManagerTestCase3} to \texttt{CrFwOutManagerTestCase8}.|
IRG|01|S|The CORDET Framework shall provide an InRegistry component as an extension of the Base Component .|The InRegistry component is created by function \texttt{CrFwInRegistryMake} which creates it as an extension of the Base State Machine.|InRegistry creation is verified in the test cases in \texttt{CrFwInRegistryTestCase.h}.|
IRG|02|A|The InRegistry component shall support the adaptation points IRG-*.|||
IRG|03|S|The InRegistry shall offer an operation StartTracking to run the Registry Start Tracking Procedure of figure \ref{fig:RegistryStartTracking} .|The StartTracking operation is implemented in function \texttt{CrFwInRegistryStartTracking}.|The Registry Start Tracking Procedure has two branches both of which are verified in test case \texttt{CrFwInRegistryTestCase2}.|
IRG|04|S|The InRegistry shall offer an Update operation which runs the Registry Update Procedure of figure \ref{fig:RegistryUpdate} .|The Update operation is implemented in function \texttt{CrFwInRegistryUpdateState}.|The Registry Update Procedure has two branches both of which are verified in test case \texttt{CrFwInRegistryTestCase2}.|
IRG|05|S|The InRegistry component shall provide an API through which the state of a command or report in the repository (PENDING, ABORTED, and TERMINATED) can be queried.|The query operation is implemented in function \texttt{CrFwInRegistryGetState}.|The query function is verified in test case \texttt{CrFwOutRegistryTestCase2}. All possible outcomes of the query function (PENDING, NOT\_TRACKED, ABORTED and TERMINATED) are verified.|
IRG|06|S|The InRegistry shall use the command/report identifier attribute as the key to store and make available information about commands and reports.|The argument of function \texttt{CrFwInRegistryGetState} is the command or report identifier.|The query function is verified in test case \texttt{CrFwInRegistryTestCase2}. |
IRG|07|C|An application shall instantiate the InRegistry component only once.|||
IRP|01|S|The CORDET Framework shall provide an InReport component as an extension of the Base Component to encapsulate an incoming report in a user application.|The InReport components are created by function \texttt{CrFwInFactoryMakeInRep} which returns an instance taken from a pool of pre-allocated components. The pre-allocated components are created by function \texttt{InFactoryInitAction} as extensions of a Base InCommand which is created by function \texttt{CrFwInRepMakeBase} and which is itself an extension of a Base State Machine.|The function \texttt{CrFwInFactoryMakeInRep} is verified in test case \texttt{CrFwInRepTestCase1}.|
IRP|02|A|The InReport component shall support the adaptation points IRP-*.|||
IRP|03|S|The InReport component shall provide visibility over the value of all the attributes of the report it encapsulates.|The InReport attributes can be accessed through functions with names like: \texttt{CrFwInRepGet*}.|The \texttt{CrFwInRepGet*} functions are verified in test case \texttt{CrFwInRepTestCase1}.|
IST|01|S|The CORDET Framework shall provide an InStream component as an extension of the Base Component.|The InStream component is created by function \texttt{CrFwInStreamMake} which creates it as an extension of the Base State Machine.|InStream creation is verified in the test cases in \texttt{CrFwOutStreamTestCase.h}.|
IST|02|S|The behaviour of the InStream component in state CONFIGURED shall be as defined by the InStream State Machine of figure \ref{fig:InStream} and by the Packet Collect Procedure of figure \ref{fig:PacketCollect} .|The function \texttt{CrFwInStreamMake} builds an instance of an InStream by first extending a Base State Machine and then embedding within its CONFIGURED state an InStream State Machine. The Packet Collect Procedure is implemented in function \texttt{DoActionB} in \texttt{CrFwInStream.h}.|The behaviour of the InStream State Machine is verified in table \ref{tab:verInStreamSM}``. The behaviour of the Packet Collect Procedure is verified in table \ref{tab:verPcktCollectProc}|
IST|03|S|The Packet Queue in the InStream shall be managed as a FIFO queue.|The packet queue of the InStream uses the implementation of module \texttt{CrFwPcktQueue}.  Module.|FIFO order management of packets in packet queues is verified in \texttt{CrFwPacketQueueTestCase1}.|
IST|04|A|The InStream component shall support the adaptation points IST-*.|||
IST|05|S|The InStream shall provide visibility over the state of its Packet Queue (number of packets in the queue and number of empty slots still available), over the InStream sequence counters, and over the sources associated to the InStream.|The number of pending packet is provided by function \texttt{CrFwInStreamGetNOfPendingPckts}; the queue size is provided by function \texttt{CrFwInStreamGetPcktQueueSize}; the sequence counter values are accessed through function \texttt{CrFwInStreamGetSeqCnt}; the InStream sources are accessed through function \texttt{CrFwInStreamGetSrc}.|The function to check the number of pending items is verified in \texttt{CrFwInStreamTestCase3}; the function to verify the size of the packet queue is verified in \texttt{CrFwInStreamTestCase4}.|
IST|06|C|The InStream shall be used with a middleware which satisfies the Middleware Assumptions B1 to B5.|||
IST|07|C|Deleted|||
IST|08|C|An InStream shall be responsible for handling all packets arriving from one or more packets sources (i.e. all packets originating from the same source go through the same InStream).|||
IST|09|C|An InStream shall only enter state CONFIGURED when its middleware connection has terminated its initialization and is either in state WAITING or PCKT\_AVAIL.|||
OCM|01|S|The CORDET Framework shall provide an OutComponent component as an extension of the Base Component.|The OutComponent components are created by function \texttt{CrFwOutFactoryMakeOutCmp} which returns an instance taken from a pool of pre-allocated components. The pre-allocated components are created by function \texttt{OutFactoryInitAction} as extensions of a Base OutComponent which is created by function \texttt{CrFwOutCmpMakeBase} and which is itself an extension of a Base State Machine.|The function \texttt{CrFwOutFactoryMakeOutCmp} is verified in test cases \texttt{CrFwOutCmpTestCase1} to \texttt{CrFwOutCmpTestCase6}. |
OCM|02|S|The behaviour of the OutComponent in state CONFIGURED shall be as defined by the OutComponent State Machine of figure \ref{fig:OutComponent.}|The function \texttt{CrFwOutCmpMakeBase} builds the Base OutComponent from which all OutComponents are derived by extending the Base State Machine and then embedding within its CONFIGURED state an OutComponent State Machine.|The behaviour of the OutComponent State Machine is verified in table \ref{tab:verOutComponentSM}.|
OCM|03|A|The OutComponent State Machine shall support the adaptation points OCM-*.|||
OCM|04|S|The OutComponent component shall provide access to the attributes of the command or report instance that the OutComponent encapsulates.|The command or report attributes can be accessed through functions with names like: \texttt{CrFwOutCmpGet*}.|The getter functions for the command and report attributes are verified in test case \texttt{CrFwOutCmpTestCase1}.|
OFT|01|S|The OutFactory component shall encapsulate the instance creation process for OutComponent components.|Instances of OutComponents are created by function \texttt{CrFwOutFactoryMakeOutCmp}.|Function  \texttt{CrFwOutFactoryMakeOutCmp} is verified in test case \texttt{CrFwOutFactoryTestCase4}.|
OFT|02|S|The \texttt{Make} operation of the OutFactory component shall take as arguments the service type, command or report sub-type and discriminant value of the command or report to be encapsulated by the OutComponent.|Instances of OutComponents are created by function \texttt{CrFwOutFactoryMakeOutCmp}.|Function  \texttt{CrFwOutFactoryMakeOutCmp} is verified in test case \texttt{CrFwOutFactoryTestCase4}.|
OFT|03|S|The OutComponents returned by the \texttt{Make} operation of the OutFactory shall have their service type, command/report sub-type, and discriminant attribute set in accordance with the value of the arguments of the \texttt{Make} operation.|Instances of OutComponents are created by function \texttt{CrFwOutFactoryMakeOutCmp}.|The correctness of the type, sub-type and discriminant of a newly created OutComponent is verified in test case \texttt{ CrFwOutCmpTestCase1}.|
OFT|04|S|The OutComponents returned by the \texttt{Make} operation of the OutFactory shall have their identifier attribute set to represent the number of components successfully created by the factory since it was initialized.|Instances of OutComponents are created by function \texttt{CrFwOutFactoryMakeOutCmp}.|The correctness of the instance identifier of a newly created OutComponent is verified in test case \texttt{ CrFwOutCmpTestCase1}.|
OFT|05|A|The OutFactory shall support the adaptation points OFT-*.|||
OLD|01|S|The CORDET Framework shall provide an OutLoader component as an extension of the Base Component.|The OutLoader component is created by function \texttt{CrFwOutLoaderMake} which creates it as an extension of the Base State Machine.|OutLoader creation is verified in the test cases in \texttt{CrFwOutLoaderTestCase.h}.|
OLD|02|A|The OutLoader component shall support the adaptation points OLD-*.|||
OLD|03|S|The OutLoader component shall offer a \texttt{Load} operation to load an OutComponent instance into an OutManager.|The Load operation is implemented by function \texttt{CrFwOutLoaderLoad}.|Function \texttt{CrFwOutLoaderLoad} is verified in test case \texttt{CrFwOutLoaderTestCase1}.|
OLD|04|S|Execution of the \texttt{Load} operation shall cause the \texttt{Load Procedure} of figure \ref{fig:OutLoaderLoad} .|The Load operation is implemented by function \texttt{CrFwOutLoaderLoad}.|The Load Procedure has one single branch which is tested in \texttt{CrFwOutLoaderTestCase1}.|
OLD|05|C|An application shall instantiate an OutLoader component only once.|||
OMG|01|S|The CORDET Framework shall provide an OutManager component as an extension of the Base Component.|The OutManager component is created by function \texttt{CrFwOutManagerMake} which creates it as an extension of the Base State Machine.|OutLoader creation is verified in the test cases in \texttt{CrFwOutManagerTestCase.h}.|
OMG|02|A|The OutManager component shall support the Adaptation Points OMG-*.|||
OMG|03|S|The OutManager component shall offer a \texttt{Load} operation to load an OutComponent instance in the POCL.|The Load operation is implemented by function \texttt{CrFwOutManagerLoad}.|Function  \texttt{CrFwOutManagerLoad} is verified in test case \texttt{CrFwOutManagerTestCase2}.|
OMG|04|S|The \texttt{Load} operation shall run the OutManager Load Procedure of figure \ref{fig:OutManagerLoad.}|The OutManager Load Procedure is implemented by function \texttt{CrFwOutManagerLoad}.|The Load Procedure has two branches both of which are verified in test case \texttt{CrFwOutManagerTestCase2}. The 'POCL Full' branch is also verified in test cases \texttt{CrFwOutManagerTestCase3} and \texttt{CrFwOutManagerTestCase4}.|
OMG|05|C|An application shall ensure that the OutComponent components loaded in an OutManager through the OutLoader are in state CONFIGURED.|||
ORG|01|S|The CORDET Framework shall provide an OutRegistry component as an extension of the Base Component.|The OutRegistry component is created by function \texttt{CrFwOutRegistryMake} which creates it as an extension of the Base State Machine.|OutRegistry creation is verified in the test cases in \texttt{CrFwOutManagerTestCase.h}.|
ORG|02|A|The OutRegistry component shall support the adaptation points ORG-*.|||
ORG|03|S|The OutRegistry shall offer a \texttt{StartTracking} operation to run the Registry Start Tracking Procedure of figure \ref{fig:RegistryStartTracking} .|The StartTracking operation is implemented in function \texttt{CrFwOutRegistryStartTracking}.|The Registry Start Tracking Procedure has two branches both of which are verified in test case \texttt{CrFwOutRegistryTestCase7}.|
ORG|04|S|The OutRegistry shall offer an \texttt{Update} operation to run the Registry Update Procedure of figure \ref{fig:RegistryUpdate} .|The Update operation is implemented in function \texttt{CrFwOutRegistryStartTracking}.|The Registry Update Procedure has two branches both of which are verified in test case \texttt{CrFwOutRegistryTestCase7}.|
ORG|05|S|The OutRegistry component shall provide an API through which the state of a command or report in the repository (PENDING, ABORTED, and TERMINATED) can be queried.|The query operation is implemented in function \texttt{CrFwOutRegistryGetState}.|The query function is verified in test cases \texttt{CrFwOutRegistryTestCase7} to \texttt{CrFwOutRegistryTestCase9}. All possible outcomes of the query function (PENDING, NOT\_TRACKED, ABORTED and TERMINATED) are verified.|
ORG|06|S|The OutRegistry component shall provide an API through which the enable state of a service type, service sub-type or discriminant value can be set and read.|The set operation is implemented in function \texttt{CrFwOutRegistrySetEnable}. The get operation is implemented in function \texttt{CrFwOutRegistryIsEnabled}.|Functions \texttt{CrFwOutRegistrySetEnable} and  \texttt{CrFwOutRegistryIsEnabled} are verified in test cases \texttt{CrFwOutRegistryTestCase3} to \texttt{CrFwOutRegistryTestCase6}.|
ORG|07|S|The OutRegistry component shall provide an API through which the enable state of a specific out-going command or report can be determined in accordance with the logic of the Enable State Determination Procedure  of figure \ref{fig:EnableStateDetermination.}|The logic to determine the enable state of an OutComponent is implemented in function \texttt{CrFwOutRegistryIsEnabled}.|The behaviour of the Enable State Determination Procedure e is verified in table \ref{tab:verEnableStateDeterminationProc}.|
ORG|08|S|The OutRegistry shall use the command/report identifier attribute as the key to store and make available information about commands and reports.|The argument of function \texttt{CrFwOutRegistryGetState} is the command or report identifier.|The query function is verified in test cases \texttt{CrFwOutRegistryTestCase7} to \texttt{CrFwOutRegistryTestCase9}. |
ORG|09|C|An application shall instantiate the OutRegistry component only once.|||
OSR|01|S|The CORDET Framework shall provide an OutStreamRegistry component as an extension of the Base Component.|The OutStreamRegistry function is implemented in the OutStream itself (in function \texttt{CrFwOutStreamGet}).|The \texttt{CrFwOutStreamGet} function is verified in test case \texttt{CrFwInStreamTestCase4}.|
OSR|02|A|TheOutStreamRegistry Component shall support the adaptation points OSR-*.|||
OSR|03|S|The OutStreamRegistry component shall define an API offering one operation: \texttt{OutStreamGet}.|The OutStreamGet operation is implemented by function \texttt{CrFwOutStreamGet}.|The \texttt{CrFwOutStreamGet} function is verified in test case \texttt{CrFwInStreamTestCase4}.|
OSR|04|S|The \texttt{OutStreamGet} operation shall either fail and return nothing, or succeed and return the OutStream component associated to the command or report destination specified in its argument.|The OutStreamGet operation is implemented by function \texttt{CrFwOutStreamGet}.|Both kinds of return values for the \texttt{CrFwOutStreamGet} function are verified in test case \texttt{CrFwInStreamTestCase4}.|
OSR|05|S|The encoding of the command or report destination passed in a call to the \texttt{OutStreamGet} operation shall be the same as the encoding of the destination attribute of commands and reports.|The argument of \texttt{CrFwOutStreamGet} is of type \texttt{CrFwDestSrc\_t} and this is the same type as used for a report or command destination in function \texttt{CrFwPcktSetDest}.|The \texttt{CrFwOutStreamGet} function is verified in test case \texttt{CrFwInStreamTestCase4}.|
OSR|06|C|An application shall instantiate the OutStreamRegistry component only once.|||
OST|01|S|The CORDET Framework shall provide an OutStream component as an extension of the Base Component.|The OutStream component is created by function \texttt{CrFwOutStreamMake} which creates it as an extension of the Base State Machine.|OutStream creation is verified in the test cases in \texttt{CrFwOutStreamTestCase.h}.|
OST|02|S|The behaviour of the OutStream component in state CONFIGURED shall be as defined by the OutStream State Machine of figure \ref{fig:OutStream} .|The function \texttt{CrFwOutStreamMake} builds an instance of an OutStream by first extending a Base State Machine and then embedding within its CONFIGURED state an OutStream State Machine.|The behaviour of the OutStream State Machine is verified in table \ref{tab:verOutStreamSM}.|
OST|03|P|The OutStream shall guarantee the OutStream Properties P1 to P4.|||
OST|04|S|The Packet Queue in the OutStream shall be managed as a FIFO queue.|The packet queue of the OutStream uses the implementation of module \texttt{CrFwPcktQueue}.  Module.|FIFO order management of packets in packet queues is verified in \texttt{CrFwPacketQueueTestCase1}.|
OST|05|A|The OutStream component shall support the adaptation points OST-*.|||
OST|06|S|The OutStream shall provide visibility over: (a) the state of its Packet Queue (number of packets in the queue and number of empty slots still available); (b) the current value of its sequence counter and its type counters; (c) the set of destinations, type and sub-types for which it maintains type counters; (d) the set of destinations associated to the OutStreams|The number of pending packet is provided by function \texttt{CrFwOutStreamGetNOfPendingPckts} and the queue size is provided by function \texttt{CrFwOutStreamGetPcktQueueSize}. The current value of the sequence counters and type counters are provided by functions \texttt{CrFwOutStreamGetSeqCntSeqCnt} and \texttt{CrFwOutStreamGetTypeCounter}. The set of destinations, type and sub-types for which type counters are maintained is checked through function \texttt{CrFwOutStreamIsInDtsSet}. The set of destinations associated to an OutStream is accessed through function \texttt{CrFwOutStreamGetDest}|The functions to check the number of pending packets and the size of the Packet Queue are verified in \texttt{CrFwOutStreamTestCase1} and  \texttt{CrFwOutStreamTestCase3}.|
OST|07|C|The OutStream shall be used with a middleware which satisfies the Middleware Assumptions A1 to A5.|||
OST|08|C|An OutStream shall be responsible for handling all packets going to one or more destinations (i.e. all packets going to the same destination go through the same OutStream)|||
OST|09|C|This requirement has been deleted|||
OST|10|C|This requirement has been deleted|||
OST|11|C|An OutStream shall only enter state CONFIGURED when its middleware connection has become AVAILABLE.|||
