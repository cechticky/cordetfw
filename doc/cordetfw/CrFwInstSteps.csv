ID|Title|SpecificationStep|ImplementationStep
01|Identify Target Application|Identify the application for which the framework is being instantiated.|The Application Identifier is specified in \texttt{CrFwUserConstants.h}.
02|Identify Service Users|Identify the users of the services provided by the target application. Each service user is identified through its Application Identifier.|The service user identifiers define the sources of incoming commands (InCommands) in \texttt{CrFwInStreamUserPar.h} and the destinations of out-going reports (OutCompnents) in \texttt{CrFwOutStreamUserPar.h}.
03|Identify Service Providers|Identify the providers of the services used by the target application. Each service provider is identified through its Application Identifier.|The service provider identifiers define the sources of incoming reports (InReports) in \texttt{CrFwInStreamUserPar.h} and the destinations of out-going commands (OutCompnents) in \texttt{CrFwOutStreamUserPar.h}.
04|Define Used Services |Define the services which are used by the target application. Each service is defined through: its identifier (the "service type"); a description of the purpose of the service; the external entity which provides the service; the commands and reports which implement the service. |The range of services used by the application is defined in \texttt{CrFwInFactoryUserPar.h} and \texttt{CrFwOutFactoryUserPar.h}. Also, a list of services supported by the application is defined in \texttt{CrFwOutRegistryUserPar.h}.
05|Define Provided Services |Define the services which are provided by the target application. Each service is defined through: its identifier (the "service type"); a description of the purpose of the service; the external entity which uses the service; the commands and reports which implement the service.  |The range of services provided by the application is defined in \texttt{CrFwInFactoryUserPar.h} and \texttt{CrFwOutFactoryUserPar.h}. Also, a list of services supported by the application is defined in \texttt{CrFwOutRegistryUserPar.h}.
06|Identify Re-Routing Capabilities|Define the applications to which incoming packets received must be re-routed.|The re-routing information is defined in the re-routing function which is provided to the framework as a function pointer in \texttt{CrFwInLoaderUserPar.h}. Also, re-routing contributes to the definition of InStreams and OutStreams (InStreams receive re-routed packets and OutStreams forward them to their end destination). See also section \ref{sec:PcktInterface}.
07|Define Incoming Commands|For each provided service, define the commands which implement it (i.e the commands which the application must be able to receive and process) in terms of: their attributes, their acceptance and ready checks, their start action, progress action, termination action, and abort action.|The detailed definition of the incoming commands is done in \texttt{CrFwInFactoryUserPar.h}. Also, for each command, a C-module must be provided which implements the functions encapsulating the command actions and checks. See module \texttt{CrFwInCmdSample1} for an example. See also section \ref{sec:InCommand}.
08|Define Incoming Reports|For each used service, define the reports which implement it (i.e. the reports which the application must be able to receive and process) in terms of: their attributes, their acceptance check, and their update action.|The detailed definition of the incoming reports is done in \texttt{CrFwInFactoryUserPar.h}. Also, for each report, a C-module must be provided which implements the functions encapsulating the report actions and checks. See module \texttt{CrFwInRepSample1} for an example. See also section \ref{sec:InReport}.
09|Define Outgoing Commands and Reports|For each provided service, define the reports which implement it and, for each used service, define the commands which implement it. Out-going commands and reports are defined in terms of: their attributes, their enable check, their ready and repeat checks and their update action.|The detailed definition of the out-going commands and reports is done in \texttt{CrFwOutFactoryUserPar.h}. Also, for out-going reports or commands which do not use the default implementations of the OutComponent adaptation points, a C-module must be provided which implements the functions encapsulating the report or command actions and checks. See module \texttt{CrFwOutCmpSample1} for an example. See also section \ref{sec:OutComponent}.
10|Assign Commands and Reports to Groups|Define command and report groups and define rules for assigning commands and reports to groups.|The definition of the assignment rules is done in the implementation of the getter and setter functions for the group attribute in module \texttt{CrFwPckt}. 
10.1|Define DTS\_SET|Define the set of out-going commands and reports for which the OutStreams must maintain and set a non-zero type counter attribute|In \texttt{CrFwOutStreamUserPar.h}, a function must be provided which can decides whether or not an out-going packet belongs to DTS\_SET (the set of destination, types and sub-types for which a type counter is maintained)
11|Define Command and Report Layout|For each command and report which can be either generated or received by the target application, define the layout of the packet which carries it.|The packet layout is implicitly implemented in the setter and getter functions of the \texttt{CrFwPckt.h} interface. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}. See also section \ref{sec:PcktImpl}.
12|Define Packet Allocation Policy|Define the allocation policy for the packets which the application creates when it receives a command or report or when it sends out a command or report.|The packet allocation policy is implemented in the \texttt{make} function of the \texttt{CrFwPckt.h} interface. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{tests/config}. See also section \ref{sec:PcktImpl}.
13|Define Command and Report Capacity|Define: the maximum number of incoming commands which the target application can hold at any given time; the maximum number of incoming reports which the target application can hold at any given time; and the maximum number of outgoing commands or reports which the application can hold at any given time. |The capacities for incoming commands and reports are defined as \texttt{\#DEFINE} constants in \texttt{CrFwInFactoryUserPar.h}. The capacity for out-going commands and reports is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwOutFactoryUserPar.h}.
14|Define Application Modes|Define the sub-states in the states of the Application State Machine.|For each set of sub-states, a state machine implementing them is defined which is then embedded in one of the states of the Application State Machine. The embedded state machines are defined in \texttt{CrFwAppSmUserApp.h}. See also section \ref{sec:AppStartUp}.
15|Define Incoming Middleware Interface|Define the interface to the middleware which is responsible for receiving the commands and reports for the target application.|An InStream should be defined for each set of command/report sources which share the same physical interface to the application. The size of the InStream packet queues and the pointers to the functions which implement the InStream operations are defined in \texttt{CrFwInStreamUserPar.h}. Also, for each InStream a C module must be defined which implements the InStream functions. A test stub is provided in \texttt{CrFwInStreamStub}. See also section \ref{sec:InStream}.
16|Define Out-Going Middleware Interface|Define the interface to the middleware which is responsible for sending out the commands and reports originating in the target application.|An OutStream should be defined for each set of destinations which share the same physical interface to the application. The size of the OutStream packet queues and the pointers to the functions which implement the OutStream operations are defined in \texttt{CrFwOutStreamUserPar.h}. Also, for each OutStream a C module must be defined which implements the OutStream functions. A test stub is provided in \texttt{CrFwOutStreamStub}. See also section \ref{sec:OutStream}.
17|Define InManagers|Define the number of InManagers and the size of their Pending Command/Report Lists (PCRLs).|These items are defined as \texttt{\#DEFINE} constants in \texttt{CrFwInManagerUserPar.h}
18|Define InManager Selection Function|Define the logic to select the InManager where an incoming command or report is loaded.|A pointer to this function is defined in \texttt{CrFwInLoaderUserPar.h}. A default implementation is provided by the InLoader component (see \texttt{CrFwInLoader.h}). See also section \ref{sec:InLoader}.
19|Define InRegistry|Define the maximum number of commands and reports which can be tracked by the InRegistry.|This item is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwInRegsitryUserPar.h}.
20|Define OutManagers|Define the number of OutManagers and the size of their Pending OutComponent Lists (POCLs).|These items are defined as \texttt{\#DEFINE} constants in \texttt{CrFwOutManagerUserPar.h}.
21|Define OutManager Selection Function|Define the logic to select the OutManager where an out-going command or report is loaded.|A pointer to this function is defined in \texttt{CrFwOutLoaderUserPar.h}. A default implementation is provided by the OutLoader component (see \texttt{CrFwOutLoader.h}). See also section \ref{sec:OutLoader}.
22|Define OutRegistry|Define the maximum number of commands and reports which can be tracked by the OutRegistry.|This item is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwOutRegistryUserPar.h}.
23|Define Start-Up Procedure|Define the start-up procedure for the application. This in particular includes the sequence in which framework components are instantiated, initialized and configured.|Implement the Application Start-Up Procedure by providing an implementation for \texttt{CrFwAppStartUpProc.h}. A test stub is provided in \texttt{CrFwAppStartUpProc.c}. See also section \ref{sec:AppStartUp}.
24|Define Reset Procedure|Define the reset procedure for the application. This in particular includes the sequence in which framework components are reset.|Implement the Application Reset Procedure by providing an implementation for \texttt{CrFwAppResetProc.h}. A test stub is provided in \texttt{CrFwAppResetProc.c}. See also section \ref{sec:AppStartUp}.
25|Define Shutdown Procedure|Define the shutdown procedure for the application. This in particular includes the sequence in which framework components are shutdown.|Implement the Application Shutdown Procedure by providing an implementation for \texttt{CrFwAppShutdownProc.h}. A test stub is provided in \texttt{CrFwAppShutdownProc.c}. See also section \ref{sec:AppStartUp}.
26|Define Time Interface|Define the means through which the current time is acquired. This is needed for time-stamping out-going commands and reports in the OutStream.|The time acquisition interface is defined in \texttt{CrFwTime.h}. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{tests/config}.
27|Define Error Reporting Interface|Define the response to the generation of error reports.|The response to error reports is defined in \texttt{CrFwRepErr.h}. The application developer must provide a complete implementation for this interface. A test implementation is provided in the configuration directory \texttt{tests/config}.
28|Define InCommand Outcome Reporting|Define the means through which the outcome of the processing of incoming commands is reported.|The respone to the reports of InCommand outcomes is defined in \texttt{CrFwRepInCmdOutcome.h}. The application developer must provide a complete implementation for this interface. A test implementation is provided in the configuration directory \texttt{tests/config}.
29|Define Primitive Types|Define the range of the primitive types used by the framework components. The driver for this definition is the need to optimize the memory footprint of the application.|The primitive types are defined through \texttt{typedef}'s in \texttt{CrFwUserConstants.h}. Application developers can override the default definitions in this file (but note that, in most cases, the default definitions should be adequate).
